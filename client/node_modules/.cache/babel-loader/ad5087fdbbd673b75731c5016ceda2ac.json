{"ast":null,"code":"import _defineProperty from \"C:\\\\Workspace\\\\Repo\\\\Smart Contract Solidity\\\\TontinarCoin\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"C:\\\\Workspace\\\\Repo\\\\Smart Contract Solidity\\\\TontinarCoin\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useState, useEffect, useCallback, useContext } from \"react\";\nimport Web3Context from \"../Web3Context\";\nexport const useKYC = props => {\n  const _useContext = useContext(Web3Context),\n        contracts = _useContext.contracts,\n        user = _useContext.user;\n\n  const kycContract = contracts.kycContract;\n\n  const _useState = useState({\n    data: {\n      isKycCompleted: false\n    },\n    isFetching: false,\n    error: null\n  }),\n        _useState2 = _slicedToArray(_useState, 2),\n        response = _useState2[0],\n        setResponse = _useState2[1];\n\n  const isKycCompletedFn = useCallback(async () => {\n    try {\n      const isKycCompleted = await kycContract.methods.isKycCompleted(user).call();\n      setResponse({\n        isFetching: false,\n        data: {\n          isKycCompleted\n        }\n      });\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        data: {\n          isKycCompleted: false\n        },\n        error: e.message\n      });\n    }\n  }, [kycContract, user]);\n  const setKycCompleted = useCallback(async kycAddress => {\n    try {\n      await kycContract.methods.setKycCompleted(kycAddress).send({\n        from: user\n      });\n      setResponse({\n        isFetching: false,\n        data: {\n          isKycCompleted: true\n        }\n      });\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        data: {\n          isKycCompleted: false\n        },\n        error: e.message\n      });\n    }\n  }, [kycContract, user]);\n  useEffect(() => {\n    isKycCompletedFn();\n  }, [isKycCompletedFn]);\n  return {\n    response,\n    isKycCompleted: isKycCompletedFn,\n    setKycCompleted\n  };\n};\nexport const useBuyToken = () => {\n  const _useContext2 = useContext(Web3Context),\n        contracts = _useContext2.contracts,\n        user = _useContext2.user;\n\n  const myTokenSale = contracts.myTokenSale,\n        myToken = contracts.myToken;\n\n  const _useState3 = useState({\n    data: {\n      userTokens: 0\n    },\n    isFetching: false,\n    error: null\n  }),\n        _useState4 = _slicedToArray(_useState3, 2),\n        response = _useState4[0],\n        setResponse = _useState4[1];\n\n  const buyToken = useCallback(async () => {\n    try {\n      await myTokenSale.methods.buyTokens(user).send({\n        from: user,\n        gas: 6000000,\n        value: 1\n      });\n      setResponse({\n        isFetching: false\n      });\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        error: e.message\n      });\n    }\n  }, [myTokenSale, user]);\n  const userTokenBalance = useCallback(async () => {\n    try {\n      const userTokens = await myToken.methods.balanceOf(user).call();\n      setResponse(prevState => _objectSpread({}, prevState, {\n        isFetching: false,\n        data: _objectSpread({}, prevState.data, {\n          userTokens\n        })\n      }));\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        error: e.message\n      });\n    }\n  }, [myTokenSale, user]);\n  useEffect(() => {\n    const listenToTokenTransfer = async () => {\n      myToken.events.Transfer({\n        to: user\n      }).on(\"data\", userTokenBalance);\n    };\n\n    userTokenBalance();\n    listenToTokenTransfer();\n  }, [userTokenBalance]);\n  return {\n    response,\n    buyToken,\n    userTokenBalance\n  };\n};","map":{"version":3,"sources":["C:/Workspace/Repo/Smart Contract Solidity/TontinarCoin/client/src/hooks/TokenHooks.js"],"names":["useState","useEffect","useCallback","useContext","Web3Context","useKYC","props","contracts","user","kycContract","data","isKycCompleted","isFetching","error","response","setResponse","isKycCompletedFn","methods","call","e","console","log","message","setKycCompleted","kycAddress","send","from","useBuyToken","myTokenSale","myToken","userTokens","buyToken","buyTokens","gas","value","userTokenBalance","balanceOf","prevState","listenToTokenTransfer","events","Transfer","to","on"],"mappings":"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","sourcesContent":["import { useState, useEffect, useCallback, useContext } from \"react\";\nimport Web3Context from \"../Web3Context\";\n\nexport const useKYC = (props) => {\n  const { contracts, user } = useContext(Web3Context);\n  const { kycContract } = contracts;\n  const [response, setResponse] = useState({\n    data: { isKycCompleted: false},\n    isFetching: false,\n    error: null,\n  });\n\n  const isKycCompletedFn = useCallback(async () => {\n    try {\n      const isKycCompleted =  await kycContract.methods.isKycCompleted(user).call();\n      setResponse({ isFetching: false, data:{ isKycCompleted } });\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        data: {isKycCompleted: false},\n        error: e.message,\n      });\n    }\n  }, [kycContract, user]);\n\n  const setKycCompleted = useCallback(async (kycAddress) => {\n    try {\n      await kycContract.methods.setKycCompleted(kycAddress).send({from: user});\n      setResponse({ isFetching: false, data:{ isKycCompleted: true } });\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        data: {isKycCompleted: false},\n        error: e.message,\n      });\n    }\n  }, [kycContract, user]);\n\n  useEffect(() => {\n    isKycCompletedFn();\n  }, [isKycCompletedFn]);\n\n\n  return { response, isKycCompleted:isKycCompletedFn, setKycCompleted};\n};\n\nexport const useBuyToken = () => {\n  const { contracts, user } = useContext(Web3Context);\n  const { myTokenSale, myToken } = contracts;\n  const [response, setResponse] = useState({\n    data: { userTokens: 0 },\n    isFetching: false,\n    error: null,\n  });\n\n  const buyToken = useCallback(async () => {\n    try {\n      await myTokenSale.methods.buyTokens(user).send({\n        from: user,\n        gas: 6000000,\n        value: 1,\n      });\n\n      setResponse({ isFetching: false });\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        error: e.message,\n      });\n    }\n  }, [myTokenSale, user]);\n\n  const userTokenBalance = useCallback(async () => {\n    try {\n        const userTokens = await myToken.methods.balanceOf(user).call();\n        setResponse((prevState) => ({\n          ...prevState,\n          isFetching: false ,\n          data: { ...prevState.data, userTokens },\n        }));\n\n    } catch (e) {\n      console.log(\"Error\", e);\n      setResponse({\n        isFetching: false,\n        error: e.message,\n      });\n    }\n  }, [myTokenSale, user]);\n\n  useEffect(() => {\n    const listenToTokenTransfer = async () => {\n      myToken.events.Transfer({ to: user }).on(\"data\", userTokenBalance);\n    };\n    userTokenBalance();\n    listenToTokenTransfer();\n  }, [userTokenBalance]);\n\n  return { response, buyToken, userTokenBalance };\n};\n"]},"metadata":{},"sourceType":"module"}